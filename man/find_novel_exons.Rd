% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/exon_discovery.R
\name{find_novel_exons}
\alias{find_novel_exons}
\title{Novel exon prediction}
\usage{
find_novel_exons(sj_filename, annotation, min_unique = 1,
  gzipped = FALSE, verbose = TRUE, bam, single_sj = TRUE,
  read_based = TRUE, yield_size = 2e+05, lib_type = "PE",
  stranded = "reverse")
}
\arguments{
\item{sj_filename}{Path to SJ.out.tab file.}

\item{annotation}{List with exon and intron annotation as GRanges. Created
with \code{\link[=prepare_annotation]{prepare_annotation()}}.}

\item{min_unique}{Minimal number of reads required to map over a splice
junction.}

\item{gzipped}{A logical scalar. Is the input file gzipped? Default FALSE.}

\item{verbose}{Print messages about the progress.}

\item{bam}{Path to BAM file.}

\item{single_sj}{A logical scalar. Should single novel splice junctions be
used for prediction? Requires a BAM file.}

\item{read_based}{A logical scalar. Should novel exons be predicted from
reads or read-pairs with two novel splice junctions? Requires a BAM file.}

\item{yield_size}{Integer scalar. Read the BAM file in chunks of this size.}

\item{lib_type}{Character scalar. Type of the sequencing library: either "SE"
(single-end) or "PE" (paired-end); default "PE".}

\item{stranded}{Character scalar. Strand type of the sequencing protocol:
"unstranded" for unstranded protocols; "forward" or "reverse" for stranded
protocols. "forward" refers to protocols where the first read comes from the
forward (sense) strand; default "reverse". See the \href{https://salmon.readthedocs.io/en/latest/library_type.html#fraglibtype}{Salmon documentation}
for an explanation of the different fragment library types.}
}
\value{
Data.frame with the coordinates of the identified novel exons. Each
row in the data.frame is a predicted novel exon. The columns are the
chromosome (\code{seqnames}), the end of the upstream exon (\code{lend}) in the
transcript, the start and end of the novel exon (\code{start} and \code{end}), the
start of the downstream exon (\code{rstart}) in the transcript and the strand
(\code{strand}). The last three columns are the number of reads supporting each
of the two splice junctions that define the novel exon: \code{unique_left} is the
number of reads supporting the SJ from \code{lend} to \code{start} and \code{unique_right}
is the number of supporting reads for the SJ from \code{end} to \code{rstart}.
\code{min_reads} is the minimum of the two.
}
\description{
Predict novel exons based on the SJ.out.tab file from STAR and/or a BAM file.
The function has three different prediction modes:
\enumerate{
\item Cassette exons
\item Novel exons from a single novel splice junction
\item Novel exons from reads/read pairs with two novel splice junctions.
}

The cassette exon prediction is always preformed and the second and third
mode can be turned on/off with the paramters \code{single_sj} and \code{read_based}.
}
\details{
The three different prediction modes are explained in more detail below:

Novel cassette exons are predicted from pairs of novel splice junctions (SJ)
that are located within an annotated intron and share the start and end
coordinates of the intron:
\preformatted{
X---------X   annotated intron
x---x         novel SJ
      x---x   novel SJ
X---NNN---X   predicted cassette exon (N)
}
First, the novel SJs are filtered: Only SJs that are located within an annotated
intron and that share their start or end coordinates with the intron are
retained. All introns that share both their start and end with a novel SJ are
tested for cassette exons. If the two novel SJs within an intron do not
overlap and are on the same strand, a novel cassette exon is predicted.

The second mode (parameter \code{single_sj}) is based on single novel SJs as input.
The novel SJs can be divided in three different cases:
\enumerate{
\item Novel SJs that touch an annotated exon with their start (5' end).
\item Novel SJs that touch annotated exons with their end (3' end).
\item Novel SJs that touch an annoated exon on both ends (5' and 3' end).
}

The three cases can be illustrated as follows:
\enumerate{
\item Start touches annotation
\preformatted{
AAAA            annotated exon
   J---J        novel SJ
 xxx---xx----x  read
       NN----X  novel exon and second SJ
   }
\item End touches annotation
\preformatted{
           AAA annotated exon
      J----J   novel SJ
xx---xx----xx  read
 X---NN        novel exon and second SJ
   }
\item Both ends touch annotation
\preformatted{
       AAAAA  annotated exon
AAAA          annotated exon
   J---J      novel junction
  NN---xxxxx  possible transcript with novel exon NN at the 5' of the SJ
xxxx---NN     possible transcript with novel exon NN at the 3' of the SJ
   }
}

For case 1 and 2, the function reads the BAM file and takes all reads that
support the novel SJ and have a second SJ. The coordinates of the second SJ,
and thus the coordinates of the novel exon are determined from the reads. In
case 3, the function searches for reads with two novel SJs that support a
possible novel exon on either end of the SJ. If no reads are found, the
function checks if the novel exon could be terminal, i.e. the first or last
exon in a transcript. If yes, the novel exon is not connected to an annotated
exon at its start/end and thus the start/end coordinate of the novel exon
cannot be determined clearly. As an approximation, the function takes the
boundaries of the read with the longest mapping to the novel exon.
The third prediction mode (parameter \code{read_based}) only uses reads and the
annotation as input. Novel exons are predicted from novel combinations of
already annotated SJs. The SJ pairs are defined by a single read with two SJs
or by read pairs where each read spans one junction. Each of the SJ pairs are
compared with the annotated SJs per transcript and already annotated SJ pairs
are removed.
For paired-end reads, there is an additional requirement: The distance between
the end of the first read in a pair and the start of the second read has to
has to be \code{< 2*(readlength-minOverhang) + minIntronSize}. Here,
\code{readlength} is the length of the reads, \code{minOverhang} is the minmal required
read overhang over a SJ of the alignment tool and \code{minIntronSize} is the
minimal required intron length of the alignment tool. For example, paired-end
reads with a lenght of 101 nts and a minimal overhang of 6 and a minimal
intron length of 21 allow a distance of at most 211 nucleotides between the
two SJs: 2*(101-6) + 21 = 211. If the distance between the two SJs exceeds the
limit, it cannot be guaranteed that the junctions are connected to the same
exon.

Novel exons are then predicted from novel combinations of the identified SJ
pairs. A novel exon is only predicted if it is contained within the boundaries
of an annotated gene. This prevents the prediction of false positive exons
because of wrongly mapped reads.
}
\examples{
sj <- system.file("extdata", "selected.SJ.out.tab",
                  package = "exondiscovery", mustWork = TRUE)
bam <- system.file("extdata", "selected.bam",
                   package = "exondiscovery", mustWork = TRUE)

## prepare annotation
gtf <- system.file("extdata", "selected.gtf", package = "exondiscovery",
                   mustWork = TRUE)
anno <- prepare_annotation(gtf)

## predict novel exons
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam)

## predict only cassette exons
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 single_sj = FALSE, read_based = FALSE)

## only predict exons from novel splice junctions
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, read_based = FALSE)

## Only consider novel splice junctions with at least ten supporting reads
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 10,
                 bam = bam)

## turn verbose off
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, verbose = FALSE)

## increase chunk size for BAM file reading if lots of memory is available
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, yield_size = 1000000)

## Stranded single-end reads from the forward strand (sense)
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, lib_type = "SE", stranded = "forward")

## Stranded paired-end reads where the first read comes from the forward strand
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, lib_type = "PE", stranded = "forward")

## Stranded paired-end reads where the first read comes from the reverse
## strand, e.g., Illumina TruSeq stranded mRNA protocol. This is the default.
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, lib_type = "PE", stranded = "reverse")

## Unstranded single-end reads
find_novel_exons(sj_filename = sj, annotation = anno, min_unique = 1,
                 bam = bam, lib_type = "SE", stranded = "unstranded")

}
